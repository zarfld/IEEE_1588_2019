#!/usr/bin/env python3
"""Generate requirements ↔ tests ↔ implementation traceability matrix.

Scans the repository for:
  - Requirement IDs (REQ-F-###) in requirements spec files under 02-requirements/
  - Test references to those IDs under 05-implementation/tests/
  - Source references under 05-implementation/src/ and include/ (comments referencing IDs)
Produces a markdown table at 07-verification-validation/traceability/requirements-test-matrix.md.

Copyright Notice:
  Implements original traceability automation logic based on understanding of
  ISO/IEC/IEEE 29148:2018 requirements engineering practices. No copyrighted
  specification text is reproduced. IEEE/AES/AVnu standards are referenced only
  by identifier tokens present in existing repository artifacts.

Usage:
  python scripts/generate_traceability_matrix.py

Future Enhancements:
  - Support additional ID taxonomies (e.g., StR-EXTS-###, ADR-###)
  - Emit CSV/JSON for CI ingestion
  - Validate schema compliance of each requirement file before extraction
"""

from __future__ import annotations
import re
import os
import pathlib
from typing import Dict, List, Set, Tuple

REPO_ROOT = pathlib.Path(__file__).resolve().parent.parent
REQ_DIR = REPO_ROOT / "02-requirements"
TEST_DIR = REPO_ROOT / "05-implementation" / "tests"
SRC_DIRS = [REPO_ROOT / "05-implementation" / "src", REPO_ROOT / "include"]
OUTPUT_FILE = REPO_ROOT / "07-verification-validation" / "traceability" / "requirements-test-matrix.md"

REQ_PATTERN = re.compile(r"REQ-F-\d{3}")
TITLE_LINE_PATTERN = re.compile(r"^\s*#{1,6}\s*(REQ-F-\d{3})[:\- ]+(?P<title>.+)$")

def find_requirement_files() -> List[pathlib.Path]:
    files: List[pathlib.Path] = []
    for root, _dirs, filenames in os.walk(REQ_DIR):
        for fn in filenames:
            if fn.endswith(".md"):
                files.append(pathlib.Path(root) / fn)
    return files

def extract_requirements(files: List[pathlib.Path]) -> Dict[str, Dict[str, str]]:
    """Return mapping: req_id -> { 'title': str, 'file': str }"""
    reqs: Dict[str, Dict[str, str]] = {}
    for f in files:
        try:
            content = f.read_text(encoding="utf-8", errors="ignore").splitlines()
        except Exception:
            continue
        for line in content:
            # Title extraction
            m = TITLE_LINE_PATTERN.match(line)
            if m:
                rid = m.group(1)
                title = m.group("title").strip()
                reqs.setdefault(rid, {"title": title, "file": str(f.relative_to(REPO_ROOT))})
            # Generic occurrence (fallback without title)
            for rid in REQ_PATTERN.findall(line):
                reqs.setdefault(rid, {"title": reqs.get(rid, {}).get("title", "(title not parsed)"), "file": str(f.relative_to(REPO_ROOT))})
    return reqs

def scan_directory_for_ids(base: pathlib.Path, ids: Set[str]) -> Dict[str, Set[str]]:
    mapping: Dict[str, Set[str]] = {rid: set() for rid in ids}
    for root, _dirs, filenames in os.walk(base):
        for fn in filenames:
            if not fn.endswith(('.cpp', '.c', '.hpp', '.h', '.md', '.txt')):
                continue
            path = pathlib.Path(root) / fn
            try:
                text = path.read_text(encoding="utf-8", errors="ignore")
            except Exception:
                continue
            present = {rid for rid in ids if rid in text}
            for rid in present:
                mapping[rid].add(str(path.relative_to(REPO_ROOT)))
    return mapping

def generate_markdown(reqs: Dict[str, Dict[str, str]], tests: Dict[str, Set[str]], impl: Dict[str, Set[str]]) -> str:
    lines: List[str] = []
    lines.append("# Requirements ↔ Tests ↔ Implementation Traceability Matrix")
    lines.append("")
    lines.append("Generated by `scripts/generate_traceability_matrix.py`. Do not edit manually; re-run the script.")
    lines.append("")
    lines.append("| Requirement ID | Title | Spec File | Test Files | Implementation References | Coverage Status |")
    lines.append("|----------------|-------|-----------|------------|---------------------------|-----------------|")
    for rid in sorted(reqs.keys()):
        title = reqs[rid]["title"] or "(title not parsed)"
        spec_file = reqs[rid]["file"]
        test_files = sorted(tests.get(rid, []))
        impl_files = sorted(impl.get(rid, []))
        coverage_status = coverage_label(bool(test_files), bool(impl_files))
        lines.append(f"| {rid} | {escape_md(title)} | `{spec_file}` | {format_list(test_files)} | {format_list(impl_files)} | {coverage_status} |")
    lines.append("")
    lines.append("## Legend")
    lines.append("- Coverage Status: FULL = tests & implementation refs present; PARTIAL = one present; NONE = neither detected.")
    lines.append("- Implementation References collected by simple substring scan; refine with more precise tagging (e.g., `@req REQ-F-202`).")
    lines.append("")
    lines.append("## Improvement Recommendations")
    for rid in sorted(reqs.keys()):
        t_present = bool(tests.get(rid))
        i_present = bool(impl.get(rid))
        if t_present and i_present:
            continue
        if not t_present and not i_present:
            lines.append(f"- {rid}: Add at least one test file and implementation reference comment (e.g., '// REQ trace: {rid}').")
        elif not t_present:
            lines.append(f"- {rid}: Add test(s) referencing {rid}.")
        elif not i_present:
            lines.append(f"- {rid}: Add inline implementation comment referencing {rid} in code handling acceptance criteria.")
    lines.append("")
    return "\n".join(lines)

def escape_md(text: str) -> str:
    # Escape pipe for markdown table cells by replacing with HTML entity
    return text.replace("|", "&#124;")

def format_list(items: List[str]) -> str:
    if not items:
        return "(none)"
    # Limit overly long lists inline
    if len(items) > 5:
        head = ", ".join(f"`{x}`" for x in items[:5])
        return f"{head}, …(+{len(items)-5})"
    return ", ".join(f"`{x}`" for x in items)

def coverage_label(has_tests: bool, has_impl: bool) -> str:
    if has_tests and has_impl:
        return "FULL"
    if has_tests or has_impl:
        return "PARTIAL"
    return "NONE"

def main() -> int:
    req_files = find_requirement_files()
    reqs = extract_requirements(req_files)
    if not reqs:
        print("No requirements found matching pattern REQ-F-###.")
        return 1
    ids = set(reqs.keys())
    test_refs = scan_directory_for_ids(TEST_DIR, ids)
    impl_refs: Dict[str, Set[str]] = {rid: set() for rid in ids}
    for d in SRC_DIRS:
        refs = scan_directory_for_ids(d, ids)
        for rid, files in refs.items():
            impl_refs[rid].update(files)
    markdown = generate_markdown(reqs, test_refs, impl_refs)
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_FILE.write_text(markdown, encoding="utf-8")
    print(f"Traceability matrix written to {OUTPUT_FILE}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
