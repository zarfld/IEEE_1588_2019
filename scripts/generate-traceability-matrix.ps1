# Requires: PowerShell 5+
# Purpose: Generate requirements ↔ tests ↔ implementation traceability matrix without external deps.

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

function Get-RepoRoot {
    param([string]$Start)
    return (Resolve-Path -LiteralPath (Join-Path $Start '.')).Path
}

# Resolve repository root as parent of the scripts directory
$repoRoot = (Resolve-Path -LiteralPath (Join-Path $PSScriptRoot '..')).Path
$reqDir   = Join-Path $repoRoot '02-requirements'
$testDir  = Join-Path $repoRoot '05-implementation\tests'
$srcDirs  = @(
    (Join-Path $repoRoot '05-implementation\src'),
    (Join-Path $repoRoot 'include')
)
$outFile  = Join-Path $repoRoot '07-verification-validation\traceability\requirements-test-matrix.md'

$reqIdRegex = 'REQ-F-\d{3}'
$titleRegex = '^[ \t]*#{1,6}[ \t]*(REQ-F-\d{3})[:\- ]+(?<title>.+)$'

# Collect requirements (IDs and titles)
$reqs = @{}
Get-ChildItem -LiteralPath $reqDir -Recurse -Include *.md | Where-Object { $_.PSIsContainer -eq $false } | ForEach-Object {
    $rel = $_.FullName.Replace($repoRoot + '\\','')
    try {
        Get-Content -LiteralPath $_.FullName -Encoding UTF8 | ForEach-Object {
        $line = $_
        $m = [Regex]::Match($line, $titleRegex)
        if ($m.Success) {
            $rid = $m.Groups[1].Value
            $title = $m.Groups['title'].Value.Trim()
            if (-not $reqs.ContainsKey($rid)) { $reqs[$rid] = @{ title=$title; file=$rel } }
        }
        foreach ($rid in ([Regex]::Matches($line, $reqIdRegex) | ForEach-Object { $_.Value } | Select-Object -Unique)) {
            if (-not $reqs.ContainsKey($rid)) { $reqs[$rid] = @{ title='(title not parsed)'; file=$rel } }
        }
        }
    } catch {
        Write-Verbose "Skipping unreadable file: $($_.FullName) ($_).Exception.Message)"
    }
}

if ($reqs.Count -eq 0) {
    Write-Host 'No requirements found matching pattern REQ-F-###.' -ForegroundColor Yellow
    exit 1
}

function Get-DirIds {
    param([string]$dir, [string[]]$ids)
    $map = @{}
    foreach ($id in $ids) { $map[$id] = @() }
    if (-not (Test-Path -LiteralPath $dir)) { return $map }
    Get-ChildItem -LiteralPath $dir -Recurse -File | Where-Object { $_.Extension -in @('.cpp','.c','.hpp','.h','.md','.txt') } | ForEach-Object {
        $relPath = $_.FullName.Replace($repoRoot + '\\','')
        $text = Get-Content -LiteralPath $_.FullName -Raw -Encoding UTF8
        foreach ($id in $ids) {
            if ($text -like "*${id}*") { $map[$id] += $relPath }
        }
    }
    # Deduplicate
    foreach ($id in $ids) { $map[$id] = $map[$id] | Select-Object -Unique }
    return $map
}

$ids = $reqs.Keys | Sort-Object
$testRefs = Get-DirIds -dir $testDir -ids $ids

# Aggregate implementation refs from multiple src dirs
$implRefs = @{}
foreach ($id in $ids) { $implRefs[$id] = @() }
foreach ($d in $srcDirs) {
    $refs = Get-DirIds -dir $d -ids $ids
    foreach ($id in $ids) { $implRefs[$id] += $refs[$id] }
}
foreach ($id in $ids) { $implRefs[$id] = $implRefs[$id] | Select-Object -Unique }

# Render Markdown
$nl = "`n"
$sb = New-Object System.Text.StringBuilder
[void]$sb.Append("# Requirements <-> Tests <-> Implementation Traceability Matrix$nl$nl")
[void]$sb.Append("Generated by `\`scripts/generate-traceability-matrix.ps1`\`. Do not edit manually; re-run the script.$nl$nl")
[void]$sb.Append("| Requirement ID | Title | Spec File | Test Files | Implementation References | Coverage Status |$nl")
[void]$sb.Append("|----------------|-------|-----------|------------|---------------------------|-----------------|$nl")

function Format-ListCell { param([string[]]$items)
    if (-not $items -or $items.Count -eq 0) { return '(none)' }
    if ($items.Count -gt 5) {
        $head = ($items | Select-Object -First 5 | ForEach-Object { "`$($_)" }) -join ", "
        return "$head, …(+$($items.Count-5))"
    }
    return ($items | ForEach-Object { "`$($_)" }) -join ", "
}

function Get-CoverageLabel { param([bool]$hasTests, [bool]$hasImpl)
    if ($hasTests -and $hasImpl) { return 'FULL' }
    if ($hasTests -or $hasImpl) { return 'PARTIAL' }
    return 'NONE'
}

foreach ($id in $ids) {
    $title = $reqs[$id].title
    $file = $reqs[$id].file
    $tests = if ($testRefs.ContainsKey($id)) { $testRefs[$id] } else { @() }
    $impl = if ($implRefs.ContainsKey($id)) { $implRefs[$id] } else { @() }
    $cov = Get-CoverageLabel -hasTests:([bool]($tests -and ($tests -is [System.Collections.ICollection]) -and $tests.Count)) -hasImpl:([bool]($impl -and ($impl -is [System.Collections.ICollection]) -and $impl.Count))
    $line = "| $id | $($title -replace '\|','&#124;') | `$($file) | $(Format-ListCell $tests) | $(Format-ListCell $impl) | $cov |$nl"
    [void]$sb.Append($line)
}

[void]$sb.Append("$nl## Legend$nl")
[void]$sb.Append("- Coverage Status: FULL = tests & implementation refs present; PARTIAL = one present; NONE = neither detected.$nl")
[void]$sb.Append("- Implementation References collected by simple substring scan; refine with more precise tagging (e.g., `@req REQ-F-202`).$nl$nl")

[void]$sb.Append("## Improvement Recommendations$nl")
foreach ($id in $ids) {
    $tests = if ($testRefs.ContainsKey($id)) { $testRefs[$id] } else { @() }
    $impl = if ($implRefs.ContainsKey($id)) { $implRefs[$id] } else { @() }
    $hasT = [bool]($tests -and ($tests -is [System.Collections.ICollection]) -and $tests.Count)
    $hasI = [bool]($impl -and ($impl -is [System.Collections.ICollection]) -and $impl.Count)
    if ($hasT -and $hasI) { continue }
    if (-not $hasT -and -not $hasI) { [void]$sb.Append("- ${id}: Add at least one test file and implementation reference comment (e.g., '// REQ trace: ${id}').$nl"); continue }
    if (-not $hasT) { [void]$sb.Append("- ${id}: Add test(s) referencing ${id}.$nl") }
    if (-not $hasI) { [void]$sb.Append("- ${id}: Add inline implementation comment referencing ${id} in code handling acceptance criteria.$nl") }
}

New-Item -ItemType Directory -Force -Path (Split-Path -Parent $outFile) | Out-Null
[System.IO.File]::WriteAllText($outFile, $sb.ToString(), [System.Text.Encoding]::UTF8)
Write-Host "Traceability matrix written to $outFile" -ForegroundColor Green
